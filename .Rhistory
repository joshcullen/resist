ndvi<- list.files()
ndvi.stack<- raster::stack(ndvi)
ndvi.stack<- raster::flip(ndvi.stack, direction = "y")
##plot
rasterVis::levelplot(ndvi.stack, at=breaks, col.regions=cols, main="NDVI")
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg/NDWI")
ndwi<- list.files()
ndwi<- list.files()
ndwi.stack<- raster::stack(ndwi)
ndwi.stack<- raster::flip(ndwi.stack, direction = "y")
breaks<- seq(-1, 1, by=0.1)
cols<- colorRampPalette(c("#00FFFF", "#0000FF"))(length(breaks)-1)
##plot
rasterVis::levelplot(ndwi.stack, at=breaks, col.regions=cols, main="NDWI")
library(tidyverse)
library(sf)
library(raster)
library(lubridate)
library(sp)
library(furrr)
library(future)
library(progressr)
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<-  dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
dat$season<- ifelse(dat$month %in% month.abb[1:7], "Flood", "Dry")
dat$season<- factor(dat$season, levels = c("Flood","Dry"))
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
## EVI
evi<- brick('GiantArm_evi_monthly.grd')
evi<- crop(evi, extent(dat %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi.s<- scale(evi)
ndwi<- brick('GiantArm_ndwi_monthly.grd')
ndwi<- crop(ndwi, evi)
ndwi.s<- scale(ndwi)
covars<- stack(ndwi$May, evi$May)
covars.df<- as.data.frame(covars, xy=T)
View(covars.df)
pairs(covars.df[,1:2])
pairs(covars.df[,3:4])
cor(covars.df[,3:4])
cor(covars.df[,3:4], na.rm=T)
covars.df<- drop_na(covars.df)
cor(covars.df[,3:4])
breaks<- seq(0, 1, by=0.01)
cols<- colorRampPalette(rev(c("00FFFF", "0000FF")))(length(
breaks)-1)
cols<- colorRampPalette(rev(c("#00FFFF", "#0000FF")))(length(
breaks)-1)
rasterVis::levelplot(ndwi, at=breaks, col.regions=cols, main="NDWI")
breaks<- seq(-0.2, 1, by=0.01)
cols<- colorRampPalette(c("#00FFFF", "#0000FF"))(length(
breaks)-1)
rasterVis::levelplot(ndwi, at=breaks, col.regions=cols, main="NDWI")
library(tidyverse)
library(sf)
library(raster)
library(lubridate)
library(sp)
library(furrr)
library(future)
source('helper functions.R')
#############################
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<-  dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
dat$season<- ifelse(dat$month %in% c(month.abb[3:5]), "Fall",
ifelse(dat$month %in% c(month.abb[6:8]), "Winter",
ifelse(dat$month %in% c(month.abb[9:11]), "Spring", "Summer")))
dat$season<- factor(dat$season, levels = c("Fall","Winter","Spring","Summer"))
#Elevation
dem<- raster('giantarm_dem.tif')
names(dem)<- 'elev'
dem
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
evi<- brick('GiantArm_evi_monthly.grd')
dem<- resample(dem, evi, method = "bilinear")
covars<- stack(dem, evi)
covars.df<- as.data.frame(covars, xy=T)
View(covars.df)
covars.df<- drop_na(covars.df)
plot(dem)
plot(evi)
cor(covars.df[,3:12])
library(Rcpp)
library(mvtnorm)
library(dplyr)
library(ggplot2)
library(lubridate)
library(tidyr)
library(tictoc)
source('gibbs_resist.R')
source('gibbs_resist_func.R')
source('slice_b_gamma.R')
source('slice_betas.R')
sourceCpp('resist_aux.cpp')
#############################
### Import armadillo data ###
#############################
path<- read.csv("Emanuel Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
### Reformat Data ###
# Center and Scale covariate
# path.s<- path %>%
#   mutate_at(c("ndvi","awei"),
#             ~scale(., center = TRUE, scale = TRUE)) %>%
#   drop_na(ndvi)
path.s<- path
path.s$month<- month.abb[month(path.s$date)]
path.s$month<- factor(path.s$month, levels = month.abb[c(5:12,1)])
#Generate sequence along dist2rd
rango1<- range(path.s$evi)
#Run splines on standardized sequence
rango2<- range(seq.dist)
#Run splines on standardized sequence
# rango2<- range(seq.dist)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)
spline.dist<- bs(seq.dist, degree=2, intercept = FALSE, knots = knot.locs)
library(splines)
spline.dist<- bs(seq.dist, degree=2, intercept = FALSE, knots = knot.locs)
seq.dist<- seq(rango1[1], rango1[2], length.out = 100)
spline.dist<- bs(seq.dist, degree=2, intercept = FALSE, knots = knot.locs)
View(spline.dist)
#Run splines on standardized sequence
# rango2<- range(seq.dist)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
spline.dist<- bs(seq.dist, degree=2, intercept = FALSE, knots = knot.locs)
View(path.s)
# Add B-spline (w/ 2 internal knots) for 'EVI'
rango<- range(path.s$evi)
knot.locs<- seq(rango[1], rango[2], length.out = 4)[2:3]
spline.evi<- as.data.frame(bs(path.s$evi, degree=2, intercept = FALSE,
knots = knot.locs))
names(spline.evi)<- paste("spline", 1:ncol(spline.evi), sep = ".")
View(spline.evi)
path.s<- cbind(path.s, spline.evi)
ind<- c(paste("spline", 1:ncol(spline.evi), sep = "."))
month.dumm<- model.matrix(~path.s$month + 0)
month.dumm<- month.dumm[,which(colSums(month.dumm) > 0)]
xmat<- data.matrix(cbind(1, month.dumm[,-1], path.s[,ind]))  #treat May as ref
View(xmat)
#reformat seg.id so it is consecutive and numeric
path.s$seg.id<- factor(path.s$seg.id)
levels(path.s$seg.id)<- 1:length(unique(path.s$seg.id))
path.s$seg.id<- as.numeric(path.s$seg.id)
#check seg.id
seg.id<- path.s$seg.id
k<- unique(seg.id)
unique(k-c(1:max(k))) #should be 0
#get y soma
cond=!is.na(path.s$dt)
ysoma=path.s[cond,'dt']
#model args
ngibbs=10000
nburn=ngibbs/2
w=0.1
MaxIter=10000
#priors
var.betas=rep(10,ncol(xmat)) #changed
#Run model
set.seed(123)
mod<- gibbs_resist(ysoma = ysoma, xmat = xmat, seg.id = seg.id,
ngibbs = ngibbs, nburn = nburn, var.betas = var.betas,
w = w, MaxIter = MaxIter)
store.llk<- mod$llk
store.b<- mod$b.gamma
store.betas<- mod$betas
#look at overall convergence
plot(store.llk, type='l')
plot(store.llk[(nburn + 1):ngibbs], type='l')
acf(store.llk[(nburn + 1):ngibbs])
plot(store.b, type='l')
plot(store.b[(nburn + 1):ngibbs], type='l')
acf(store.b[(nburn + 1):ngibbs])
#look at convergence betas
par(mfrow=c(2,2))
nbetas<- ncol(mod$betas)
for (i in 1:nbetas){
plot(mod$betas[,i], type='l')
}
View(xmat)
View(path.s)
summary(path.s$evi)
View(spline.evi)
# Center and Scale covariate
# path.s<- path %>%
#   mutate_at(c("ndvi","awei"),
#             ~scale(., center = TRUE, scale = TRUE)) %>%
#   drop_na(ndvi)
path.s<- path
path.s$month<- month.abb[month(path.s$date)]
path.s$month<- factor(path.s$month, levels = month.abb[c(5:12,1)])
# Add B-spline (w/ 2 internal knots) for 'EVI'
rango<- range(path.s$evi)
knot.locs<- seq(rango[1], rango[2], length.out = 4)[2:3]
spline.evi<- as.data.frame(bs(path.s$evi, degree=2, intercept = FALSE,
knots = knot.locs))
names(spline.evi)<- paste("spline", 1:ncol(spline.evi), sep = ".")
path.s<- cbind(path.s, spline.evi)
ind<- c(paste("spline", 1:ncol(spline.evi), sep = "."))
month.dumm<- model.matrix(~path.s$month + 0)
month.dumm<- month.dumm[,which(colSums(month.dumm) > 0)]  #remove months w/o observations
xmat<- data.matrix(cbind(month.dumm[,-1], path.s[,ind]))  #treat May as ref
View(xmat)
View(path.s)
#reformat seg.id so it is consecutive and numeric
path.s$seg.id<- factor(path.s$seg.id)
levels(path.s$seg.id)<- 1:length(unique(path.s$seg.id))
path.s$seg.id<- as.numeric(path.s$seg.id)
#check seg.id
seg.id<- path.s$seg.id
k<- unique(seg.id)
unique(k-c(1:max(k))) #should be 0
#get y soma
cond=!is.na(path.s$dt)
ysoma=path.s[cond,'dt']
#model args
ngibbs=10000
nburn=ngibbs/2
w=0.1
MaxIter=10000
#priors
var.betas=rep(10,ncol(xmat)) #changed
#Run model
set.seed(123)
mod<- gibbs_resist(ysoma = ysoma, xmat = xmat, seg.id = seg.id,
ngibbs = ngibbs, nburn = nburn, var.betas = var.betas,
w = w, MaxIter = MaxIter)
store.llk<- mod$llk
store.b<- mod$b.gamma
store.betas<- mod$betas
#look at overall convergence
plot(store.llk, type='l')
par(mfrow=c(1,1),mar=rep(3,4))
#look at overall convergence
plot(store.llk, type='l')
plot(store.llk[(nburn + 1):ngibbs], type='l')
acf(store.llk[(nburn + 1):ngibbs])
plot(store.b, type='l')
plot(store.b[(nburn + 1):ngibbs], type='l')
acf(store.b[(nburn + 1):ngibbs])
#look at convergence betas
par(mfrow=c(2,2))
nbetas<- ncol(mod$betas)
for (i in 1:nbetas){
plot(mod$betas[,i], type='l')
}
for (i in 1:nbetas){
plot(mod$betas[(nburn + 1):ngibbs, i], type='l')
}
par(mfrow=c(1,1),mar=rep(3,4))
library(ggridges)
library(raster)
library(lubridate)
#look at betas (convert to data frame)
store.betas<- data.frame(mod$betas[(nburn+1):ngibbs, ])
names(store.betas)<- c("Jun","Sep","Oct","Nov",paste("spline", 1:ncol(spline.evi), sep = "."))
View(store.betas)
store.betas.long<- tidyr::pivot_longer(store.betas,
cols = names(store.betas),
names_to = "betas")
store.betas.long$betas<- factor(store.betas.long$betas,
levels = names(store.betas))
ggplot(store.betas.long, aes(x=betas, y=value)) +
geom_boxplot(color="firebrick") +
geom_hline(yintercept = 0, size = 0.5) +
labs(x="Effect Sizes", y="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
ggplot(store.betas.long, aes(y=betas, x=value, fill = betas)) +
geom_density_ridges() +
scale_fill_viridis_d("Coeffs", guide = guide_legend(reverse = TRUE)) +
geom_vline(xintercept = 0, size = 0.5) +
labs(y="Effect Sizes", x="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
path<- read.csv("Emanuel Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
#Generate sequence along green
rango1<- range(path$evi)
seq.evi<- seq(rango1[1], rango1[2], length.out = 100)
#Run splines on standardized sequence
# rango2<- range(seq.dist2)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
spline.evi<- bs(seq.evi, degree=2, intercept = FALSE, knots = knot.locs)
#Create design matrix where 0s added for all other non-spline vars
design.mat<- cbind(matrix(0, nrow = 100, ncol = 4), spline.evi)
betas<- colMeans(store.betas)
betas
y.mu<- exp(design.mat %*% betas)
# Add results to data frame
y.mu.df<- data.frame(x = seq.evi,
y = y.mu#,
# ymin = y.low,
# ymax = y.up,
# id = id1[i]
)
# Plot relationship
ggplot(data = y.mu.df) +
# geom_ribbon(aes(x=x, ymin=ymin, ymax=ymax, fill = id), alpha =  0.3) +
geom_line(aes(x, y), size = 1) +
# scale_color_brewer("", palette = "Dark2") +
# scale_fill_brewer("", palette = "Dark2") +
labs(x = "\nStandardized EVI", y = "Time Spent per Cell (min)\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 12))
store.betas.mcmc<- coda::as.mcmc(store.betas)
betas.summ<- coda::HPDinterval(store.betas.mcmc)
View(betas.summ)
betas<- coda::HPDinterval(store.betas.mcmc)
colMeans(store.betas.mcmc)
betas$mean<- colMeans(store.betas.mcmc)
betas<- as.data.frame(coda::HPDinterval(store.betas.mcmc))
betas$mean<- colMeans(store.betas.mcmc)
View(betas)
betas
y.mu<- exp(design.mat %*% betas$mean)
y.low<- exp(design.mat %*% betas$lower)
y.up<- exp(design.mat %*% betas$upper)
# Add results to data frame
y.mu.df<- data.frame(x = seq.evi,
y = y.mu,
ymin = y.low,
ymax = y.up
)
# Plot relationship
ggplot(data = y.mu.df) +
geom_ribbon(aes(x=x, ymin=ymin, ymax=ymax, fill = id), alpha =  0.3) +
geom_line(aes(x, y), size = 1) +
# scale_color_brewer("", palette = "Dark2") +
# scale_fill_brewer("", palette = "Dark2") +
labs(x = "\nStandardized EVI", y = "Time Spent per Cell (min)\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 12))
# Plot relationship
ggplot(data = y.mu.df) +
geom_ribbon(aes(x=x, ymin=ymin, ymax=ymax), alpha =  0.3) +
geom_line(aes(x, y), size = 1) +
# scale_color_brewer("", palette = "Dark2") +
# scale_fill_brewer("", palette = "Dark2") +
labs(x = "\nStandardized EVI", y = "Time Spent per Cell (min)\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text = element_text(size = 12))
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<-  dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
dat$season<- ifelse(dat$month %in% month.abb[1:7], "Flood", "Dry")
dat.em<-  dat %>%
filter(id == "emanuel")
#extract beta coeffs (mean)
betas<- colMeans(store.betas)
betas
#Load env raster data
## EVI
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
evi<- brick('GiantArm_evi_monthly.grd')
evi.s<- scale(evi, center = T, scale = T)
evi.s<- crop(evi.s, extent(dat.em %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
##Perform raster math using beta coeffs
resistSurf<- list()
evi.s2<- evi.s[[which(names(evi.s) %in% unique(path.s$month))]]
evi.s2
betas
i=1
ifelse(i == 1, 0, betas[i])
i=2
ifelse(i == 1, 0, betas[i])
ifelse(i == 1, 0, betas[i-1])
for (i in 1:length(unique(path.s$month))) {
resistSurf[[i]]<- exp(
ifelse(i == 1, 0, betas[i-1]) +
betas["spline.1"]*evi.s2[[i]] +
betas["spline.2"]*evi.s2[[i]] +
betas["spline.3"]*evi.s2[[i]] +
betas["spline.4"]*evi.s2[[i]]
)
}
resistSurf<- stack(resistSurf)
names(evi.s2)
names(resistSurf)<- names(evi.s2)
resistSurf.df<- as.data.frame(resistSurf, xy=T) %>%
pivot_longer(cols = -c(x,y), names_to = "month", values_to = "time")
# mutate(month = rep(month.abb[c(5:12,1)], each = ncell(ndwi$May)))
resistSurf.df$month<- factor(resistSurf.df$month, levels = names(evi.s2))
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent", limits = c(0,4)) +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "red") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent") +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "red") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent", limits = c(0,7)) +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "red") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent", limits = c(0,10)) +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "chartreuse") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
