#run gibbs
mod=mixture_movement(dat=dat,alpha=alpha,ngibbs=ngibbs,nmaxclust=nmaxclust,nburn=nburn)
#look at convergence
seq1=1:ngibbs
seq1=nburn:ngibbs
plot(mod$loglikel[seq1], type='l')
mod$theta
# Determine the MAP estimate of the posterior
MAP.iter<- bayesmove::get_MAP_internal(dat = mod$loglikel, nburn = nburn)
theta<- mod$theta[MAP.iter,]
names(theta)<- 1:length(theta)
theta<- sort(theta, decreasing = TRUE)
theta
theta %>% cumsum()  #first 3 states likely (represent 92.1% of all assigned states)
cumsum(theta)
# Store cluster order for plotting and behavioral state extraction
ord<- as.numeric(names(theta))
# Extract bin estimates for each possible state from the `phi` matrix of the model results
behav.res<- get_behav_hist(dat = mod, nburn = nburn, ngibbs = ngibbs, nmaxclust = nmaxclust,
var.names = c("Speed","Turning Angle"),
ord = ord, MAP.iter = MAP.iter)
# Extract bin estimates for each possible state from the `phi` matrix of the model results
behav.res<- bayesmove::get_behav_hist(dat = mod, nburn = nburn, ngibbs = ngibbs, nmaxclust = nmaxclust,
var.names = c("Speed","Turning Angle"),
ord = ord, MAP.iter = MAP.iter)
# Plot state-dependent distributions
ggplot(behav.res, aes(x = bin, y = prop, fill = as.factor(behav))) +
geom_bar(stat = 'identity') +
labs(x = "\nBin", y = "Proportion\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text.y = element_text(size = 14),
axis.text.x.bottom = element_text(size = 12),
strip.text = element_text(size = 14),
strip.text.x = element_text(face = "bold")) +
scale_fill_manual(values = c(viridis::viridis(2), rep("grey35", 8)), guide = FALSE) +
scale_y_continuous(breaks = c(0.00, 0.50, 1.00)) +
# scale_x_continuous(breaks = 1:8) +
facet_grid(behav ~ var, scales = "free_x")
library(ggplot2)
# Plot state-dependent distributions
ggplot(behav.res, aes(x = bin, y = prop, fill = as.factor(behav))) +
geom_bar(stat = 'identity') +
labs(x = "\nBin", y = "Proportion\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text.y = element_text(size = 14),
axis.text.x.bottom = element_text(size = 12),
strip.text = element_text(size = 14),
strip.text.x = element_text(face = "bold")) +
scale_fill_manual(values = c(viridis::viridis(2), rep("grey35", 8)), guide = FALSE) +
scale_y_continuous(breaks = c(0.00, 0.50, 1.00)) +
# scale_x_continuous(breaks = 1:8) +
facet_grid(behav ~ var, scales = "free_x")
View(mod)
phi1<- lapply(mod$phi, function(x) x[MAP.iter])
View(phi1)
View(mod)
phi1<- lapply(mod$phi, function(x) x[MAP.iter,])
View(phi1)
apply(dat, 2, max)
apply(dat, 2, max, na.rm=T)
phi1<- lapply(mod$phi, function(x) matrix(x[MAP.iter,], nrow = 10, byrow = T))
View(phi1)
lapply(phi1, function(x) apply(x,1,sum))
lapply(phi1, function(x) apply(x,2,sum))
phi1<- lapply(mod$phi, function(x) matrix(x[MAP.iter,], ncol = 10, byrow = T))
lapply(phi1, function(x) apply(x,2,sum))
plot(phi1[[1]][,1], type = "h")
plot(phi1[[2]][,1], type = "h")
ncol(phi1[[1]])
par(mfrow=c(10,2))
for(i in 1:ncol(phi1[[1]])) {
plot(phi1[[1]][,i], type = "h")
plot(phi1[[2]][,i], type = "h")
}
par(mfrow=c(5,2))
for(i in 1:5) {
plot(phi1[[1]][,i], type = "h")
plot(phi1[[2]][,i], type = "h")
}
par(mfrow=c(3,2))
for(i in 1:3) {
plot(phi1[[1]][,i], type = "h")
plot(phi1[[2]][,i], type = "h")
}
par(mfrow=c(2,2))
for(i in 1:2) {
plot(phi1[[1]][,i], type = "h")
plot(phi1[[2]][,i], type = "h")
}
# Plot state-dependent distributions
ggplot(behav.res, aes(x = bin, y = prop, fill = as.factor(behav))) +
geom_bar(stat = 'identity') +
labs(x = "\nBin", y = "Proportion\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text.y = element_text(size = 14),
axis.text.x.bottom = element_text(size = 12),
strip.text = element_text(size = 14),
strip.text.x = element_text(face = "bold")) +
scale_fill_manual(values = c(viridis::viridis(2), rep("grey35", 8)), guide = FALSE) +
scale_y_continuous(breaks = c(0.00, 0.50, 1.00)) +
# scale_x_continuous(breaks = 1:8) +
facet_grid(behav ~ var, scales = "free_x")
theta<- mod$theta[MAP.iter,]
theta
names(theta)<- 1:length(theta)
names
theta
theta<- sort(theta, decreasing = TRUE)
theta %>% cumsum()  #first 3 states likely (represent 92.1% of all assigned states)
theta
# Plot state-dependent distributions
ggplot(behav.res, aes(x = bin, y = prop, fill = factor(behav, levels = 1:10))) +
geom_bar(stat = 'identity') +
labs(x = "\nBin", y = "Proportion\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text.y = element_text(size = 14),
axis.text.x.bottom = element_text(size = 12),
strip.text = element_text(size = 14),
strip.text.x = element_text(face = "bold")) +
scale_fill_manual(values = c(viridis::viridis(2), rep("grey35", 8)), guide = FALSE) +
scale_y_continuous(breaks = c(0.00, 0.50, 1.00)) +
# scale_x_continuous(breaks = 1:8) +
facet_grid(behav ~ var, scales = "free_x")
library('MCMCpack')
library('Rcpp')
set.seed(3)
dat0=read.csv('Armadillo edited1.csv',as.is=T)
dat=data.matrix(dat0[,c('SL1','TA1')])
#prior
alpha=0.1
#initialize parameters
nmaxclust=10
#MCMC stuff
ngibbs=20000
nburn=ngibbs/2
#run gibbs
mod=bayesmove::cluster_obs(dat=dat,alpha=alpha,ngibbs=ngibbs,nmaxclust=nmaxclust,nburn=nburn)
View(dat0)
dat=dat0[,c('id','SL1','TA1')]
set.seed(3)
dat0=read.csv('Armadillo edited1.csv',as.is=T)
dat=dat0[,c('id','SL1','TA1')]
#prior
alpha=0.1
#initialize parameters
nmaxclust=10
#MCMC stuff
ngibbs=20000
nburn=ngibbs/2
#run gibbs
mod=bayesmove::cluster_obs(dat=dat,alpha=alpha,ngibbs=ngibbs,nmaxclust=nmaxclust,nburn=nburn)
View(mod)
seq1=nburn:ngibbs
plot(mod$loglikel[seq1], type='l')
# Determine the MAP estimate of the posterior
MAP.iter<- bayesmove::get_MAP_internal(dat = mod$loglikel, nburn = nburn)
theta<- mod$theta[MAP.iter,]
names(theta)<- 1:length(theta)
theta<- sort(theta, decreasing = TRUE)
theta %>% cumsum()  #first 3 states likely (represent 92.1% of all assigned states)
cumsum(theta)
# Store cluster order for plotting and behavioral state extraction
ord<- as.numeric(names(theta))
# Extract bin estimates for each possible state from the `phi` matrix of the model results
behav.res<- bayesmove::get_behav_hist(dat = mod, nburn = nburn, ngibbs = ngibbs, nmaxclust = nmaxclust,
var.names = c("Speed","Turning Angle"),
ord = ord, MAP.iter = MAP.iter)
# Plot state-dependent distributions
ggplot(behav.res, aes(x = bin, y = prop, fill = factor(behav, levels = 1:10))) +
geom_bar(stat = 'identity') +
labs(x = "\nBin", y = "Proportion\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text.y = element_text(size = 14),
axis.text.x.bottom = element_text(size = 12),
strip.text = element_text(size = 14),
strip.text.x = element_text(face = "bold")) +
scale_fill_manual(values = c(viridis::viridis(2), rep("grey35", 8)), guide = FALSE) +
scale_y_continuous(breaks = c(0.00, 0.50, 1.00)) +
# scale_x_continuous(breaks = 1:8) +
facet_grid(behav ~ var, scales = "free_x")
library(ggplot2)
# Plot state-dependent distributions
ggplot(behav.res, aes(x = bin, y = prop, fill = factor(behav, levels = 1:10))) +
geom_bar(stat = 'identity') +
labs(x = "\nBin", y = "Proportion\n") +
theme_bw() +
theme(axis.title = element_text(size = 16),
axis.text.y = element_text(size = 14),
axis.text.x.bottom = element_text(size = 12),
strip.text = element_text(size = 14),
strip.text.x = element_text(face = "bold")) +
scale_fill_manual(values = c(viridis::viridis(2), rep("grey35", 8)), guide = FALSE) +
scale_y_continuous(breaks = c(0.00, 0.50, 1.00)) +
# scale_x_continuous(breaks = 1:8) +
facet_grid(behav ~ var, scales = "free_x")
phi1<- lapply(mod$phi, function(x) matrix(x[MAP.iter,], ncol = 10, byrow = T))
lapply(phi1, function(x) apply(x,2,sum))
par(mfrow=c(2,2))
for(i in 1:2) {
plot(phi1[[1]][,i], type = "h")
plot(phi1[[2]][,i], type = "h")
}
library(tidyverse)
library(sf)
library(raster)
library(lubridate)
library(sp)
library(furrr)
library(future)
source('helper functions.R')
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
head(dat)
str(dat)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<-  dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
dat$season<- ifelse(dat$month %in% month.abb[1:7], "Flood", "Dry")
str(dat)
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
ndvi<- brick('GiantArm_ndvi_season.grd')
plot(ndvi)
plot(ndvi)
ndvi
ndvi<- crop(ndvi, extent(dat %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
plot(ndvi)
plot(ndvi)
#######################################################
### Extract values from raster layer for each track ###
#######################################################
plan(multisession)
path.N<- extract.covars(data = dat, layers = ndvi, state.col = "z.post.thresh")
warnings()
future:::ClusterRegistry("stop")  #close all threads and memory used
View(path.N)
View(path.N)
path<- path.N
head(path
head(path)
head(path)
months(path$date[1])
month(path$date[1])
ifelse(month(path$date[1]) %in% 1:7, path$Flood, path$Dry)
ifelse(month(path$date[1:10]) %in% 1:7, path$Flood, path$Dry)
path$ndvi<- ifelse(month(path$date) %in% 1:7, path$Flood, path$Dry)
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist")
View(path)
path<- path[,-c("Flood","Dry")]
path<- path %>%
dplyr::select(-c(Flood, Dry))
View(path)
# Armadillo Data
write.csv(path, "Giant Armadillo Resistance Data.csv", row.names = F)
library(Rcpp)
library(mvtnorm)
library(dplyr)
library(ggplot2)
library(tidyr)
library(tictoc)
source('gibbs_resist.R')
source('gibbs_resist_func.R')
source('slice_b_gamma.R')
source('slice_betas.R')
sourceCpp('resist_aux.cpp')
path<- read.csv("Giant Armadillo Resistance Data.csv", as.is = T)
View(path)
path$dt<- path$dt/60  #convert to min from sec
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 6 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
# Center and Scale covariate
path.s<- path %>%
mutate_at(c("ndvi"),
~scale(., center = TRUE, scale = TRUE)) %>%
drop_na(ndvi)
ind<- "ndvi"
ind<- "ndvi"
xmat<- data.matrix(cbind(1, path.s[,ind]))
path.s<- path %>%
mutate_at(c("ndvi"),
~scale(., center = TRUE, scale = TRUE))
path<- read.csv("Giant Armadillo Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
# Center and Scale covariate
path.s<- path %>%
mutate_at(c("ndvi"),
~scale(., center = TRUE, scale = TRUE)) %>%
drop_na(ndvi)
ind<- "ndvi"
xmat<- data.matrix(cbind(1, path.s[,ind]))
#reformat seg.id so it is consecutive and numeric
path.s$seg.id<- factor(path.s$seg.id)
levels(path.s$seg.id)<- 1:length(unique(path.s$seg.id))
path.s$seg.id<- as.numeric(path.s$seg.id)
#check seg.id
seg.id<- path.s$seg.id
k<- unique(seg.id)
unique(k-c(1:max(k))) #should be 0
# Center and Scale covariate
path.s<- path %>%
mutate_at(c("ndvi"),
~scale(., center = TRUE, scale = TRUE)) %>%
drop_na(ndvi)
#check seg.id
seg.id<- path.s$seg.id
k<- unique(seg.id)
unique(k-c(1:max(k))) #should be 0
#check seg.id
seg.id<- path.s$seg.id
k<- unique(seg.id)
unique(k-c(1:max(k))) #should be 0
#reformat seg.id so it is consecutive and numeric
path.s$seg.id<- factor(path.s$seg.id)
levels(path.s$seg.id)<- 1:length(unique(path.s$seg.id))
path.s$seg.id<- as.numeric(path.s$seg.id)
#check seg.id
seg.id<- path.s$seg.id
k<- unique(seg.id)
unique(k-c(1:max(k))) #should be 0
#get y soma
cond=!is.na(path.s$dt)
ysoma=path.s[cond,'dt']
#model args
ngibbs=2000
nburn=ngibbs/2
w=0.1
MaxIter=10000
#priors
var.betas=rep(10,ncol(xmat)) #changed
#Run model
set.seed(123)
mod<- gibbs_resist(ysoma = ysoma, xmat = xmat, seg.id = seg.id,
ngibbs = ngibbs, nburn = nburn, var.betas = var.betas,
w = w, MaxIter = MaxIter)
#store results
store.llk<- mod$llk
store.b<- mod$b.gamma
store.betas<- mod$betas
#look at overall convergence
plot(store.llk, type='l')
dev.off()
#look at overall convergence
plot(store.llk, type='l')
abline(v=nburn, col='red')
plot(store.llk[(nburn + 1):ngibbs], type='l')
acf(store.llk[(nburn + 1):ngibbs])
plot(store.b, type='l')
plot(store.b[(nburn + 1):ngibbs], type='l')
acf(store.b[(nburn + 1):ngibbs])
#look at convergence betas
par(mfrow=c(2,2))
nbetas<- ncol(mod$betas)
for (i in 1:nbetas){
plot(mod$betas[,i], type='l')
}
for (i in 1:nbetas){
plot(mod$betas[(nburn + 1):ngibbs, i], type='l')
}
par(mfrow=c(1,1),mar=rep(3,4))
#look at betas (convert to data frame)
store.betas<- data.frame(mod$betas[(nburn+1):ngibbs, ])
View(mod)
names(store.betas)<- c("int","ndvi")
store.betas.long<- tidyr::pivot_longer(store.betas,
cols = names(store.betas),
names_to = "betas")
store.betas.long$betas<- factor(store.betas.long$betas,
levels = names(store.betas))
ggplot(store.betas.long, aes(x=betas, y=value)) +
geom_boxplot(color="firebrick") +
geom_hline(yintercept = 0, size = 0.5) +
labs(x="Effect Sizes", y="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
ggplot(store.betas.long, aes(x=betas, y=value)) +
geom_boxplot(color="firebrick") +
geom_hline(yintercept = 0, size = 0.5) +
labs(x="Effect Sizes", y="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
ggplot(store.betas.long, aes(x=betas, y=value)) +
geom_boxplot(color="firebrick") +
geom_hline(yintercept = 0, size = 0.5) +
labs(x="Effect Sizes", y="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
ggplot(store.betas.long %>% filter(betas != "int"),aes(y=betas, x=value, fill = betas)) +
geom_density_ridges() +
scale_fill_viridis_d("Coeffs", guide = guide_legend(reverse = TRUE)) +
geom_vline(xintercept = 0, size = 0.5) +
labs(y="Effect Sizes", x="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
library(ggridges)
library(raster)
ggplot(store.betas.long %>% filter(betas != "int"),aes(y=betas, x=value, fill = betas)) +
geom_density_ridges() +
scale_fill_viridis_d("Coeffs", guide = guide_legend(reverse = TRUE)) +
geom_vline(xintercept = 0, size = 0.5) +
labs(y="Effect Sizes", x="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
ggplot(store.betas.long), aes(y=betas, x=value, fill = betas)) +
geom_density_ridges() +
scale_fill_viridis_d("Coeffs", guide = guide_legend(reverse = TRUE)) +
geom_vline(xintercept = 0, size = 0.5) +
labs(y="Effect Sizes", x="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
ggplot(store.betas.long, aes(y=betas, x=value, fill = betas)) +
geom_density_ridges() +
scale_fill_viridis_d("Coeffs", guide = guide_legend(reverse = TRUE)) +
geom_vline(xintercept = 0, size = 0.5) +
labs(y="Effect Sizes", x="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
#Load data to plot tracks
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<-  dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
dat$season<- ifelse(dat$month %in% month.abb[1:7], "Flood", "Dry")
#extract beta coeffs (mean)
betas<- colMeans(store.betas)
betas
#Load env raster data
## NDVI
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
ndvi<- brick('GiantArm_ndvi_season.grd')
ndvi<- crop(ndvi, extent(dat %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
ndvi.s<- scale(ndvi, center = T, scale = T)
##Perform raster math using beta coeffs
resistSurf_flood<- exp(
betas["int"] +
betas["ndvi"]*ndvi.s$Flood  #for Flood
)
resistSurf_flood.df<- as.data.frame(resistSurf_flood, xy=T) %>%
mutate(season = "Flood")
resistSurf_dry<- exp(
betas["int"] +
betas["ndvi"]*ndvi.s$Dry  #for Dry
)
resistSurf_dry.df<- as.data.frame(resistSurf_dry, xy=T) %>%
mutate(season = "Dry")
#Combine all results together for each season
resistSurf.df<- rbind(resistSurf_flood.df, resistSurf_dry.df)
View(resistSurf.df)
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = layer)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent") +
# geom_point(data = dat.N %>% filter(state == "Foraging"), aes(x, y, color = id),
#            size = 0.5, alpha = 0.2, show.legend = F) +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ season)
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist")
