xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi.s2<- evi.s[[which(names(evi.s) %in% unique(dat.em$month))]]
#Run splines on standardized sequence
rango1<- range(path$evi)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
spline.evi<- bs(values(evi.s2), degree=2, intercept = FALSE, knots = knot.locs)
month.dumm<- factor(rep(unique(dat.em$month), each = ncell(evi.s2)), levels = unique(dat.em$month))
month.dumm<- model.matrix(~month.dumm + 0)
design.mat<- cbind(month.dumm[,-1], spline.evi)
resistVals<- as.vector(exp(design.mat %*% betas))
resistSurf<- evi.s2
values(resistSurf)<- resistVals
plot(resistSurf)
resistSurf.df<- as.data.frame(resistSurf, xy=T) %>%
pivot_longer(cols = -c(x,y), names_to = "month", values_to = "time")
resistSurf.df$month<- factor(resistSurf.df$month, levels = names(evi.s2))
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent", limits = c(0,10)) +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "chartreuse") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent") +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "chartreuse") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
write.csv(resistSurf.df, "Giant Armadillo Resistance Surfaces.csv")
library(tidyverse)
library(ggridges)
library(raster)
library(lubridate)
### Load data ###
path<- read.csv("Emanuel Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
path$month<- month.abb[month(path$date)]
path$month<- factor(path$month, levels = month.abb[c(5:12,1)])
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
store.betas<- read.csv("Giant Armadillo Resistance Results.csv", as.is = T)
#look only at betas
store.betas<- store.betas[,2:9]
store.betas.long<- tidyr::pivot_longer(store.betas,
cols = names(store.betas),
names_to = "betas")
store.betas.long$betas<- factor(store.betas.long$betas, levels = names(store.betas))
ggplot(store.betas.long, aes(x=betas, y=value)) +
geom_boxplot(color="firebrick") +
geom_hline(yintercept = 0, size = 0.5) +
labs(x="Effect Sizes", y="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
ggplot(store.betas.long, aes(y=betas, x=value, fill = betas)) +
geom_density_ridges() +
scale_fill_viridis_d("Coeffs", guide = guide_legend(reverse = TRUE)) +
geom_vline(xintercept = 0, size = 0.5) +
labs(y="Effect Sizes", x="Value") +
theme_bw() +
theme(axis.title = element_text(size = 14),
axis.text = element_text(size = 12),
legend.title = element_text(size = 12))
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<- dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
# dat$season<- ifelse(dat$month %in% month.abb[1:7], "Flood", "Dry")
dat.em<-  dat %>%
filter(id == "emanuel")
#extract beta coeffs (mean)
betas<- colMeans(store.betas)
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
evi<- brick('GiantArm_evi_monthly.grd')
evi<- crop(evi, extent(dat %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi[getValues(evi) > 1 | getValues(evi) < -1]<- NA  #mask pixels where values are outside of accepted range
evi.s<- scale(evi)
evi.s<- crop(evi.s, extent(dat.em %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi.s
##Perform raster math using beta coeffs
evi.s2<- evi.s[[which(names(evi.s) %in% unique(dat.em$month))]]
rango1<- range(path$evi)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
spline.evi<- bs(values(evi.s2), degree=2, intercept = FALSE, knots = knot.locs)
month.dumm<- factor(rep(unique(dat.em$month), each = ncell(evi.s2)), levels = unique(dat.em$month))
month.dumm<- model.matrix(~month.dumm + 0)
design.mat<- cbind(month.dumm[,-1], spline.evi)
resistVals<- as.vector(exp(design.mat %*% betas))
resistSurf<- evi.s2
values(resistSurf)<- resistVals
library(splines)
##Perform raster math using beta coeffs
evi.s2<- evi.s[[which(names(evi.s) %in% unique(dat.em$month))]]
#Run splines on standardized sequence
rango1<- range(path$evi)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
spline.evi<- bs(values(evi.s2), degree=2, intercept = FALSE, knots = knot.locs)
month.dumm<- factor(rep(unique(dat.em$month), each = ncell(evi.s2)), levels = unique(dat.em$month))
month.dumm<- model.matrix(~month.dumm + 0)
design.mat<- cbind(month.dumm[,-1], spline.evi)
resistVals<- as.vector(exp(design.mat %*% betas))
resistSurf<- evi.s2
values(resistSurf)<- resistVals
resistSurf
plot(resistSurf)
resistSurf.df<- as.data.frame(resistSurf, xy=T) %>%
pivot_longer(cols = -c(x,y), names_to = "month", values_to = "time")
resistSurf.df$month<- factor(resistSurf.df$month, levels = names(evi.s2))
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent") +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "chartreuse") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist")
write.csv(resistSurf.df, "Giant Armadillo Resistance Surfaces.csv", row.names = F)
citation()
library(tidyverse)
library(ggridges)
library(raster)
library(lubridate)
library(splines)
### Load data ###
path<- read.csv("Emanuel Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
path$month<- month.abb[month(path$date)]
path$month<- factor(path$month, levels = month.abb[c(5:12,1)])
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
store.betas<- read.csv("Giant Armadillo Resistance Results.csv", as.is = T)
#look only at betas
store.betas<- store.betas[,2:9]
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<- dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
# dat$season<- ifelse(dat$month %in% month.abb[1:7], "Flood", "Dry")
dat.em<-  dat %>%
filter(id == "emanuel")
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
evi<- brick('GiantArm_evi_monthly.grd')
evi<- crop(evi, extent(dat %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi[getValues(evi) > 1 | getValues(evi) < -1]<- NA  #mask pixels where values are outside of accepted range
evi.s<- scale(evi)
evi.s<- crop(evi.s, extent(dat.em %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi.s2<- evi.s[[which(names(evi.s) %in% unique(dat.em$month))]]
#Run splines on standardized sequence
rango1<- range(path$evi)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
spline.evi<- bs(values(evi.s2), degree=2, intercept = FALSE, knots = knot.locs)
month.dumm<- factor(rep(unique(dat.em$month), each = ncell(evi.s2)), levels = unique(dat.em$month))
month.dumm<- model.matrix(~month.dumm + 0)
design.mat<- cbind(month.dumm[,-1], spline.evi)
#create list where months are separated into different elements
design.mat.list<- list()
oo = 1
for (i in 1:nlayers(evi.s2)) {
design.mat.list[[i]]<- design.mat[oo:(oo - 1 + ncell(evi.s2)),]
oo = oo + ncell(evi.s2)
}
dat.list<- design.mat.list
betas<- store.betas
#progress bar
pb<- progress::progress_bar$new(
format = " iteration (:current/:total) [:bar] :percent [Elapsed: :elapsed, Remaining: :eta]",
total = nrow(betas), clear = FALSE, width = 100)
tmp<- matrix(NA, nrow = nrow(betas), ncol = nrow(dat.list))
dat.list<- design.mat.list[[1]]
tmp<- matrix(NA, nrow = nrow(betas), ncol = nrow(dat.list))
for (i in 1:nrow(betas))  {
tmp[i,]<- exp(dat.list %*% t(betas[i,]))
pb$tick()  #create progress bar
}
rowMeans(tmp)
rowMeans(tmp, na.rm = T)
which.min(rowMeans(tmp, na.rm = T))
tmp[which.min(rowMeans(tmp, na.rm = T)),]
predict.speed<- function(dat.list, betas) {
tictoc::tic()
#progress bar
pb<- progress::progress_bar$new(
format = " iteration (:current/:total) [:bar] :percent [Elapsed: :elapsed, Remaining: :eta]",
total = nrow(betas), clear = FALSE, width = 100)
tmp<- matrix(NA, nrow = nrow(betas), ncol = nrow(dat.list))
for (i in 1:nrow(betas))  {
tmp[i,]<- exp(dat.list %*% t(betas[i,]))
pb$tick()  #create progress bar
}
resistVals<- data.frame(min = tmp[which.min(rowMeans(tmp, na.rm = T)),],
mean = colMeans(tmp, na.rm = T),
max = tmp[which.max(rowMeans(tmp, na.rm = T)),]
)
tictoc::toc()
resistVals
}
resistVals<- list()
resistVals[[1]]<- predict.speed(design.mat.list[[1]], store.betas)  #2 min
141/60
View(resistVals)
rm(tmp)
head(resistVals[[1]])
resistSurf<- evi.s2
resistSurf
resistSurf<- resistSurf[[1:3]]
resistSurf
unlist(resistVals[[1]])
values(resistSurf)<- unlist(resistVals[[1]])
plot(resistSurf)
resistSurf.df<- as.data.frame(resistSurf, xy=T) %>%
pivot_longer(cols = -c(x,y), names_to = "month", values_to = "time")
resistSurf.df$month<- factor(resistSurf.df$month, levels = names(evi.s2))
## Map predictive surfaces
ggplot() +
geom_tile(data = resistSurf.df, aes(x, y, fill = time)) +
scale_fill_viridis_c("Time Spent\nper Cell (min)", option = "inferno",
na.value = "transparent") +
geom_point(data = dat.em, aes(x, y),
size = 0.5, alpha = 0.5, show.legend = F, color = "chartreuse") +
scale_x_continuous(expand = c(0,0)) +
scale_y_continuous(expand = c(0,0)) +
labs(x="Easting", y="Northing") +
theme_bw() +
coord_equal() +
theme(legend.position = "bottom",
axis.title = element_text(size = 18),
axis.text = element_text(size = 10),
strip.text = element_text(size = 16, face = "bold"),
plot.title = element_text(size = 22),
legend.title = element_text(size = 14),
legend.text = element_text(size = 12)) +
guides(fill = guide_colourbar(barwidth = 30, barheight = 1)) +
facet_wrap(~ month)
rm(resistSurf)
rm(resistSurf.df)
resistVals[[2]]<- predict.speed(design.mat.list[[2]], store.betas)  #2.5 min
114/60
resistVals[[3]]<- predict.speed(design.mat.list[[3]], store.betas)  #2.5 min
resistVals[[4]]<- predict.speed(design.mat.list[[4]], store.betas)  #2.5 min
resistVals[[5]]<- predict.speed(design.mat.list[[5]], store.betas)  #2.5 min
library(Rcpp)
library(mvtnorm)
library(dplyr)
library(ggplot2)
library(lubridate)
library(tidyr)
library(tictoc)
library(splines)
source('gibbs_resist.R')
source('gibbs_resist_func.R')
source('slice_b_gamma.R')
source('slice_betas.R')
sourceCpp('resist_aux.cpp')
path<- read.csv("Emanuel Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
### Reformat Data ###
# Center and Scale covariate
# path.s<- path %>%
#   mutate_at(c("ndvi","awei"),
#             ~scale(., center = TRUE, scale = TRUE)) %>%
#   drop_na(ndvi)
path.s<- path
path.s$month<- month.abb[month(path.s$date)]
path.s$month<- factor(path.s$month, levels = month.abb[c(5:12,1)])
library(Rcpp)
library(mvtnorm)
library(dplyr)
library(ggplot2)
library(lubridate)
library(tidyr)
library(tictoc)
library(splines)
source('gibbs_resist.R')
source('gibbs_resist_func.R')
source('slice_b_gamma.R')
source('slice_betas.R')
sourceCpp('resist_aux.cpp')
path<- read.csv("Emanuel Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
# Center and Scale covariate
# path.s<- path %>%
#   mutate_at(c("ndvi","awei"),
#             ~scale(., center = TRUE, scale = TRUE)) %>%
#   drop_na(ndvi)
path.s<- path
path.s$month<- month.abb[month(path.s$date)]
path.s$month<- factor(path.s$month, levels = month.abb[c(5:12,1)])
# Add B-spline (w/ 2 internal knots) for 'EVI'
rango<- range(path.s$evi)
knot.locs<- seq(rango[1], rango[2], length.out = 4)#[2:3]
spline.evi<- as.data.frame(bs(path.s$evi, degree=2, intercept = FALSE,
knots = knot.locs))
View(spline.evi)
names(spline.evi)<- paste("spline", 1:ncol(spline.evi), sep = ".")
path.s<- cbind(path.s, spline.evi)
ind<- c(paste("spline", 1:ncol(spline.evi), sep = "."))
month.dumm<- model.matrix(~path.s$month + 0)
month.dumm<- month.dumm[,which(colSums(month.dumm) > 0)]  #remove months w/o observations
xmat<- data.matrix(cbind(month.dumm[,-1], path.s[,ind]))  #treat May as ref
colnames(xmat)[1:4]<- c("Jun","Sep","Oct","Nov")
#reformat seg.id so it is consecutive and numeric
path.s$seg.id<- factor(path.s$seg.id)
levels(path.s$seg.id)<- 1:length(unique(path.s$seg.id))
path.s$seg.id<- as.numeric(path.s$seg.id)
#check seg.id
seg.id<- path.s$seg.id
k<- unique(seg.id)
unique(k-c(1:max(k))) #should be 0
#get y soma
cond=!is.na(path.s$dt)
ysoma=path.s[cond,'dt']
#model args
ngibbs=10000
nburn=ngibbs/2
w=0.1
MaxIter=10000
#priors
var.betas=rep(10,ncol(xmat))
View(xmat)
#Run model
set.seed(123)
mod<- gibbs_resist(ysoma = ysoma, xmat = xmat, seg.id = seg.id,
ngibbs = ngibbs, nburn = nburn, var.betas = var.betas,
w = w, MaxIter = MaxIter)
#store results
store.llk<- mod$llk
store.b<- mod$b.gamma
store.betas<- mod$betas
#look at overall convergence
plot(store.llk, type='l')
plot(store.llk[(nburn + 1):ngibbs], type='l')
acf(store.llk[(nburn + 1):ngibbs])
plot(store.b, type='l')
plot(store.b[(nburn + 1):ngibbs], type='l')
acf(store.b[(nburn + 1):ngibbs])
#look at convergence betas
par(mfrow=c(2,2))
nbetas<- ncol(mod$betas)
for (i in 1:nbetas){
plot(mod$betas[,i], type='l')
}
library(tidyverse)
library(ggridges)
library(raster)
library(lubridate)
library(splines)
### Load data ###
path<- read.csv("Emanuel Resistance Data.csv", as.is = T)
path$dt<- path$dt/60  #convert to min from sec
path$month<- month.abb[month(path$date)]
path$month<- factor(path$month, levels = month.abb[c(5:12,1)])
# Filter data for only steps with 6 >= dt >= 8 min
cond<- path[path$dt >= 6 & path$dt <= 8 & !is.na(path$dt), "seg.id"]
path<- path[path$seg.id %in% cond,]
store.betas<- read.csv("Giant Armadillo Resistance Results.csv", as.is = T)
#look only at betas
store.betas<- store.betas[,2:9]
setwd("~/Documents/Snail Kite Project/Data/R Scripts/acceleration")
dat<- read.csv('Giant Armadillo state estimates.csv', as.is = T)
dat$date<- as_datetime(dat$date, tz = "UTC")
dat<- dat %>%
rename(x = easting, y = northing) %>%
mutate(across(c('z.map','z.post.thresh','z.post.max'), factor,
levels = c("Slow-Turn","Slow-Unif","Exploratory","Transit","Unclassified"))
)
dat$month<- month.abb[month(dat$date)]
dat$month<- factor(dat$month, levels = month.abb[c(5:12,1)])
# dat$season<- ifelse(dat$month %in% month.abb[1:7], "Flood", "Dry")
dat.em<-  dat %>%
filter(id == "emanuel")
setwd("~/Documents/Snail Kite Project/Data/R Scripts/ValleLabUF/resist_avg")
evi<- brick('GiantArm_evi_monthly.grd')
evi<- crop(evi, extent(dat %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi[getValues(evi) > 1 | getValues(evi) < -1]<- NA  #mask pixels where values are outside of accepted range
evi.s<- scale(evi)
evi.s<- crop(evi.s, extent(dat.em %>%
summarize(xmin = min(x) - 3000,
xmax = max(x) + 3000,
ymin = min(y) - 3000,
ymax = max(y) + 3000) %>%
unlist()))
evi.s2<- evi.s[[which(names(evi.s) %in% unique(dat.em$month))]]
#Run splines on standardized sequence
rango1<- range(path$evi)
knot.locs<- seq(rango1[1], rango1[2], length.out = 4)[2:3]
spline.evi<- bs(values(evi.s2), degree=2, intercept = FALSE, knots = knot.locs)
month.dumm<- factor(rep(unique(dat.em$month), each = ncell(evi.s2)), levels = unique(dat.em$month))
month.dumm<- model.matrix(~month.dumm + 0)
design.mat<- cbind(month.dumm[,-1], spline.evi)
design.mat.list<- list()
oo = 1
for (i in 1:nlayers(evi.s2)) {
design.mat.list[[i]]<- design.mat[oo:(oo - 1 + ncell(evi.s2)),]
oo = oo + ncell(evi.s2)
}
predict.speed<- function(dat.list, betas) {
tictoc::tic()
#progress bar
pb<- progress::progress_bar$new(
format = " iteration (:current/:total) [:bar] :percent [Elapsed: :elapsed, Remaining: :eta]",
total = nrow(betas), clear = FALSE, width = 100)
tmp<- matrix(NA, nrow = nrow(betas), ncol = nrow(dat.list))
for (i in 1:nrow(betas))  {
tmp[i,]<- exp(dat.list %*% t(betas[i,]))
pb$tick()  #create progress bar
}
resistVals<- data.frame(min = tmp[which.min(rowMeans(tmp, na.rm = T)),],
mean = colMeans(tmp, na.rm = T),
max = tmp[which.max(rowMeans(tmp, na.rm = T)),]
)
tictoc::toc()
resistVals
}
resistVals<- list()
resistVals[[1]]<- predict.speed(design.mat.list[[1]], store.betas)  #2.5 min
resistVals[[2]]<- predict.speed(design.mat.list[[2]], store.betas)  #2 min
resistVals[[3]]<- predict.speed(design.mat.list[[3]], store.betas)  #2 min
resistVals[[4]]<- predict.speed(design.mat.list[[4]], store.betas)  #2 min
resistVals[[5]]<- predict.speed(design.mat.list[[5]], store.betas)  #2 min
